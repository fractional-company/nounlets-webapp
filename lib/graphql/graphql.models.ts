// Leave this in as it is not generated by the below tool
// This is graphql meta object and its always the same
export type _Meta = {
  block: {
    hash: string // This should be bytes?
    number: number
    timestamp: string
  }
  deployment: string
  hasIndexingErrors: boolean
}

// Manually generated from https://transform.tools/graphql-to-typescript
// with "./nounlets.schema.graphql"
// NOTE: uncomment first five lines in nounlets.schema.graphql when usin the above tool

export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  BigInt: any
}

export type Token = {
  __typename?: 'Token'
  /** The Token Address */
  id: Scalars['ID']
  /** Accounts that belong to this vault */
  accounts: Array<Account>
  /** Delegates that belong to this vault */
  delegates: Array<Delegate>
}

export type Vault = {
  __typename?: 'Vault'
  /** The Vault's address */
  id: Scalars['ID']
  /** A Noun that the Vault holds */
  noun?: Maybe<Noun>
  /** Token address associated with the vault */
  token: Token
}

export type Noun = {
  __typename?: 'Noun'
  /** The Noun's ERC721 token id */
  id: Scalars['ID']
  /** The current delegate address of the Noun (Zero Address by default) */
  currentDelegate: Scalars['String']
  /** Fractions of a Noun */
  nounlets: Array<Nounlet>
}

export type Account = {
  __typename?: 'Account'
  /** Token Address + Wallet Address */
  id: Scalars['ID']
  /** The Token that the Delegate depends on */
  token: Token
  /** The sum of the nounlets held by the Account */
  nounletsHeldCount: Scalars['Int']
  /** The Nounlets held by this account */
  nounletsHeld: Array<Nounlet>
  /** Bids the Account has offered */
  bids: Array<Bid>
}

export type Delegate = {
  __typename?: 'Delegate'
  /** Token Address + Wallet Address */
  id: Scalars['ID']
  /** The Token that the Delegate depends on */
  token: Token
  /** The sum of the nounlets represented by the Delegate */
  nounletsRepresentedCount: Scalars['Int']
  /** Nounlets that this delegate represents */
  nounletsRepresented: Array<Nounlet>
  /** Historic data about the votes for this delegate */
  votes: Array<DelegateVote>
}

export type Nounlet = {
  __typename?: 'Nounlet'
  /** Token Address + Token ID */
  id: Scalars['ID']
  /** The Noun ID that the Nounlet is derived from */
  noun?: Maybe<Noun>
  /** A Nounlet holder */
  holder?: Maybe<Account>
  /** Nounlet delegate */
  delegate?: Maybe<Delegate>
  /** Auction belonging to a Nounlet */
  auction: Auction
  /** Delegate votes that the Nounlet casted */
  delegateVotes: Array<DelegateVote>
}

export type Auction = {
  __typename?: 'Auction'
  /** Token Address + Token ID */
  id: Scalars['ID']
  /** A Nounlet this Auction is meant for */
  nounlet: Nounlet
  /** The current highest bid amount */
  highestBidAmount: Scalars['BigInt']
  /** The account with the current highest bid */
  highestBidder?: Maybe<Account>
  /** Whether or not the auction has been settled */
  settled: Scalars['Boolean']
  /** The time that the auction started */
  startTime: Scalars['BigInt']
  /** The time that the auction is scheduled to end */
  endTime: Scalars['BigInt']
  /** A collection of Bids on the Auction */
  bids: Array<Bid>
}

export type Bid = {
  __typename?: 'Bid'
  /** Bid transaction hash */
  id: Scalars['ID']
  /** The auction being bid in */
  auction: Auction
  /** Bidder account */
  bidder: Account
  /** Bid amount */
  amount: Scalars['BigInt']
  /** Block number of the bid */
  blockNumber: Scalars['BigInt']
  /** The timestamp of the block the bid is in */
  blockTimestamp: Scalars['BigInt']
  /** Index of transaction within block */
  txIndex: Scalars['BigInt']
}

export type DelegateVote = {
  __typename?: 'DelegateVote'
  /** Delegate ID + Nounlet ID */
  id: Scalars['ID']
  /** Nounlet that casts a vote. Can be NULL if vote was casted as a consequence of  */
  nounlet: Nounlet
  /** Delegate receiving a vote */
  delegate: Delegate
  /** The amount of votes */
  voteAmount: Scalars['BigInt']
  /** The optional vote reason */
  reason?: Maybe<Scalars['String']>
  /** Timestamp of the vote */
  timestamp: Scalars['BigInt']
}
