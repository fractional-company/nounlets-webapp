# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Account {
    "Bids the Account has offered"
    bids(first: Int = 100, orderBy: Bid_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Bid_filter): [Bid!]!
    "The delegate this Account voted for with their Nounlets"
    delegate: Delegate
    "Delegate votes this Account is a delegator of"
    delegateVotes(first: Int = 100, orderBy: DelegateVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DelegateVote_filter): [DelegateVote!]!
    "Token Address + Wallet Address"
    id: ID!
    "The Nounlets held by this account"
    nounletsHeld(first: Int = 100, orderBy: Nounlet_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Nounlet_filter): [Nounlet!]!
    "IDs of Nounlets held (subgraph cannot fetch them from derived fields)"
    nounletsHeldIDs: [String!]!
    "The Token that the Delegate depends on"
    token: Token!
}

type Auction {
    "A collection of Bids on the Auction"
    bids(first: Int = 100, orderBy: Bid_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Bid_filter): [Bid!]!
    "The time that the auction is scheduled to end"
    endTime: BigInt!
    "The current highest bid amount"
    highestBidAmount: BigInt!
    "The account with the current highest bid"
    highestBidder: Account
    "Token Address + Token ID"
    id: ID!
    "A Nounlet this Auction is meant for"
    nounlet: Nounlet!
    "Whether or not the auction has been settled"
    settled: Boolean!
    "The transaction hash the auction was settled in"
    settledTransactionHash: String!
    "The time that the auction started"
    startTime: BigInt!
}

type Bid {
    "Bid amount"
    amount: BigInt!
    "The auction being bid in"
    auction: Auction!
    "Bidder account"
    bidder: Account!
    "Block number of the bid"
    blockNumber: BigInt!
    "The timestamp of the block the bid is in"
    blockTimestamp: BigInt!
    "Bid transaction hash"
    id: ID!
    "Index of transaction within block"
    txIndex: BigInt!
}

type Delegate {
    "Token Address + Wallet Address"
    id: ID!
    "Nounlets that this delegate represents"
    nounletsRepresented(first: Int = 100, orderBy: Nounlet_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Nounlet_filter): [Nounlet!]!
    "IDs of the represented Nounlets (subgraph cannot fetch them from derived fields)"
    nounletsRepresentedIDs: [String!]!
    "The Token that the Delegate depends on"
    token: Token!
    "Historic data about the votes for this delegate"
    votes(first: Int = 100, orderBy: DelegateVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DelegateVote_filter): [DelegateVote!]!
}

type DelegateVote {
    "Delegate receiving a vote"
    delegate: Delegate!
    "The Account that delegated the vote"
    delegator: Account
    "Delegate ID + Nounlet ID"
    id: ID!
    "Nounlet that casts a vote. Can be NULL if vote was casted as a consequence of "
    nounlet: Nounlet!
    "The optional vote reason"
    reason: String
    "Timestamp of the vote"
    timestamp: BigInt!
    "The amount of votes"
    voteAmount: BigInt!
}

type Noun {
    "The current delegate address of the Noun (Zero Address by default)"
    currentDelegate: String!
    "The Noun's ERC721 token id"
    id: ID!
    "Fractions of a Noun"
    nounlets(first: Int = 100, orderBy: Nounlet_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Nounlet_filter): [Nounlet!]!
}

type Nounlet {
    "Auction belonging to a Nounlet"
    auction: Auction!
    "Nounlet delegate"
    delegate: Delegate
    "Delegate votes that the Nounlet casted"
    delegateVotes(first: Int = 100, orderBy: DelegateVote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DelegateVote_filter): [DelegateVote!]!
    "A Nounlet holder"
    holder: Account
    "Token Address + Token ID"
    id: ID!
    "The Noun ID that the Nounlet is derived from"
    noun: Noun
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    auction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Auction
    auctions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Auction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Auction_filter
    ): [Auction!]!
    bid(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bid
    bids(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Bid_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Bid_filter
    ): [Bid!]!
    delegate(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Delegate
    delegateVote(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DelegateVote
    delegateVotes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DelegateVote_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DelegateVote_filter
    ): [DelegateVote!]!
    delegates(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Delegate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Delegate_filter
    ): [Delegate!]!
    noun(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Noun
    nounlet(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Nounlet
    nounlets(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Nounlet_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Nounlet_filter
    ): [Nounlet!]!
    nouns(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Noun_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Noun_filter
    ): [Noun!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
    vault(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Vault
    vaults(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Vault_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Vault_filter
    ): [Vault!]!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    auction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Auction
    auctions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Auction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Auction_filter
    ): [Auction!]!
    bid(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bid
    bids(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Bid_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Bid_filter
    ): [Bid!]!
    delegate(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Delegate
    delegateVote(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DelegateVote
    delegateVotes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DelegateVote_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DelegateVote_filter
    ): [DelegateVote!]!
    delegates(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Delegate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Delegate_filter
    ): [Delegate!]!
    noun(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Noun
    nounlet(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Nounlet
    nounlets(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Nounlet_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Nounlet_filter
    ): [Nounlet!]!
    nouns(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Noun_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Noun_filter
    ): [Noun!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
    vault(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Vault
    vaults(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Vault_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Vault_filter
    ): [Vault!]!
}

type Token {
    "Accounts that belong to this vault"
    accounts(first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Account_filter): [Account!]!
    "Delegates that belong to this vault"
    delegates(first: Int = 100, orderBy: Delegate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Delegate_filter): [Delegate!]!
    "The Token Address"
    id: ID!
}

type Vault {
    "The Vault's address"
    id: ID!
    "A Noun that the Vault holds"
    noun: Noun
    "Indicates whether a Noun is in the Vault"
    nounInVault: Boolean!
    "Token address associated with the vault"
    token: Token!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum Account_orderBy {
    bids
    delegate
    delegateVotes
    id
    nounletsHeld
    nounletsHeldIDs
    token
}

enum Auction_orderBy {
    bids
    endTime
    highestBidAmount
    highestBidder
    id
    nounlet
    settled
    settledTransactionHash
    startTime
}

enum Bid_orderBy {
    amount
    auction
    bidder
    blockNumber
    blockTimestamp
    id
    txIndex
}

enum DelegateVote_orderBy {
    delegate
    delegator
    id
    nounlet
    reason
    timestamp
    voteAmount
}

enum Delegate_orderBy {
    id
    nounletsRepresented
    nounletsRepresentedIDs
    token
    votes
}

enum Noun_orderBy {
    currentDelegate
    id
    nounlets
}

enum Nounlet_orderBy {
    auction
    delegate
    delegateVotes
    holder
    id
    noun
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum Token_orderBy {
    accounts
    delegates
    id
}

enum Vault_orderBy {
    id
    noun
    nounInVault
    token
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input Account_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    bids_: Bid_filter
    delegate: String
    delegateVotes_: DelegateVote_filter
    delegate_: Delegate_filter
    delegate_contains: String
    delegate_contains_nocase: String
    delegate_ends_with: String
    delegate_ends_with_nocase: String
    delegate_gt: String
    delegate_gte: String
    delegate_in: [String!]
    delegate_lt: String
    delegate_lte: String
    delegate_not: String
    delegate_not_contains: String
    delegate_not_contains_nocase: String
    delegate_not_ends_with: String
    delegate_not_ends_with_nocase: String
    delegate_not_in: [String!]
    delegate_not_starts_with: String
    delegate_not_starts_with_nocase: String
    delegate_starts_with: String
    delegate_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nounletsHeldIDs: [String!]
    nounletsHeldIDs_contains: [String!]
    nounletsHeldIDs_contains_nocase: [String!]
    nounletsHeldIDs_not: [String!]
    nounletsHeldIDs_not_contains: [String!]
    nounletsHeldIDs_not_contains_nocase: [String!]
    nounletsHeld_: Nounlet_filter
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Auction_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    bids_: Bid_filter
    endTime: BigInt
    endTime_gt: BigInt
    endTime_gte: BigInt
    endTime_in: [BigInt!]
    endTime_lt: BigInt
    endTime_lte: BigInt
    endTime_not: BigInt
    endTime_not_in: [BigInt!]
    highestBidAmount: BigInt
    highestBidAmount_gt: BigInt
    highestBidAmount_gte: BigInt
    highestBidAmount_in: [BigInt!]
    highestBidAmount_lt: BigInt
    highestBidAmount_lte: BigInt
    highestBidAmount_not: BigInt
    highestBidAmount_not_in: [BigInt!]
    highestBidder: String
    highestBidder_: Account_filter
    highestBidder_contains: String
    highestBidder_contains_nocase: String
    highestBidder_ends_with: String
    highestBidder_ends_with_nocase: String
    highestBidder_gt: String
    highestBidder_gte: String
    highestBidder_in: [String!]
    highestBidder_lt: String
    highestBidder_lte: String
    highestBidder_not: String
    highestBidder_not_contains: String
    highestBidder_not_contains_nocase: String
    highestBidder_not_ends_with: String
    highestBidder_not_ends_with_nocase: String
    highestBidder_not_in: [String!]
    highestBidder_not_starts_with: String
    highestBidder_not_starts_with_nocase: String
    highestBidder_starts_with: String
    highestBidder_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nounlet: String
    nounlet_: Nounlet_filter
    nounlet_contains: String
    nounlet_contains_nocase: String
    nounlet_ends_with: String
    nounlet_ends_with_nocase: String
    nounlet_gt: String
    nounlet_gte: String
    nounlet_in: [String!]
    nounlet_lt: String
    nounlet_lte: String
    nounlet_not: String
    nounlet_not_contains: String
    nounlet_not_contains_nocase: String
    nounlet_not_ends_with: String
    nounlet_not_ends_with_nocase: String
    nounlet_not_in: [String!]
    nounlet_not_starts_with: String
    nounlet_not_starts_with_nocase: String
    nounlet_starts_with: String
    nounlet_starts_with_nocase: String
    settled: Boolean
    settledTransactionHash: String
    settledTransactionHash_contains: String
    settledTransactionHash_contains_nocase: String
    settledTransactionHash_ends_with: String
    settledTransactionHash_ends_with_nocase: String
    settledTransactionHash_gt: String
    settledTransactionHash_gte: String
    settledTransactionHash_in: [String!]
    settledTransactionHash_lt: String
    settledTransactionHash_lte: String
    settledTransactionHash_not: String
    settledTransactionHash_not_contains: String
    settledTransactionHash_not_contains_nocase: String
    settledTransactionHash_not_ends_with: String
    settledTransactionHash_not_ends_with_nocase: String
    settledTransactionHash_not_in: [String!]
    settledTransactionHash_not_starts_with: String
    settledTransactionHash_not_starts_with_nocase: String
    settledTransactionHash_starts_with: String
    settledTransactionHash_starts_with_nocase: String
    settled_in: [Boolean!]
    settled_not: Boolean
    settled_not_in: [Boolean!]
    startTime: BigInt
    startTime_gt: BigInt
    startTime_gte: BigInt
    startTime_in: [BigInt!]
    startTime_lt: BigInt
    startTime_lte: BigInt
    startTime_not: BigInt
    startTime_not_in: [BigInt!]
}

input Bid_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    auction: String
    auction_: Auction_filter
    auction_contains: String
    auction_contains_nocase: String
    auction_ends_with: String
    auction_ends_with_nocase: String
    auction_gt: String
    auction_gte: String
    auction_in: [String!]
    auction_lt: String
    auction_lte: String
    auction_not: String
    auction_not_contains: String
    auction_not_contains_nocase: String
    auction_not_ends_with: String
    auction_not_ends_with_nocase: String
    auction_not_in: [String!]
    auction_not_starts_with: String
    auction_not_starts_with_nocase: String
    auction_starts_with: String
    auction_starts_with_nocase: String
    bidder: String
    bidder_: Account_filter
    bidder_contains: String
    bidder_contains_nocase: String
    bidder_ends_with: String
    bidder_ends_with_nocase: String
    bidder_gt: String
    bidder_gte: String
    bidder_in: [String!]
    bidder_lt: String
    bidder_lte: String
    bidder_not: String
    bidder_not_contains: String
    bidder_not_contains_nocase: String
    bidder_not_ends_with: String
    bidder_not_ends_with_nocase: String
    bidder_not_in: [String!]
    bidder_not_starts_with: String
    bidder_not_starts_with_nocase: String
    bidder_starts_with: String
    bidder_starts_with_nocase: String
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    txIndex: BigInt
    txIndex_gt: BigInt
    txIndex_gte: BigInt
    txIndex_in: [BigInt!]
    txIndex_lt: BigInt
    txIndex_lte: BigInt
    txIndex_not: BigInt
    txIndex_not_in: [BigInt!]
}

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input DelegateVote_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    delegate: String
    delegate_: Delegate_filter
    delegate_contains: String
    delegate_contains_nocase: String
    delegate_ends_with: String
    delegate_ends_with_nocase: String
    delegate_gt: String
    delegate_gte: String
    delegate_in: [String!]
    delegate_lt: String
    delegate_lte: String
    delegate_not: String
    delegate_not_contains: String
    delegate_not_contains_nocase: String
    delegate_not_ends_with: String
    delegate_not_ends_with_nocase: String
    delegate_not_in: [String!]
    delegate_not_starts_with: String
    delegate_not_starts_with_nocase: String
    delegate_starts_with: String
    delegate_starts_with_nocase: String
    delegator: String
    delegator_: Account_filter
    delegator_contains: String
    delegator_contains_nocase: String
    delegator_ends_with: String
    delegator_ends_with_nocase: String
    delegator_gt: String
    delegator_gte: String
    delegator_in: [String!]
    delegator_lt: String
    delegator_lte: String
    delegator_not: String
    delegator_not_contains: String
    delegator_not_contains_nocase: String
    delegator_not_ends_with: String
    delegator_not_ends_with_nocase: String
    delegator_not_in: [String!]
    delegator_not_starts_with: String
    delegator_not_starts_with_nocase: String
    delegator_starts_with: String
    delegator_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nounlet: String
    nounlet_: Nounlet_filter
    nounlet_contains: String
    nounlet_contains_nocase: String
    nounlet_ends_with: String
    nounlet_ends_with_nocase: String
    nounlet_gt: String
    nounlet_gte: String
    nounlet_in: [String!]
    nounlet_lt: String
    nounlet_lte: String
    nounlet_not: String
    nounlet_not_contains: String
    nounlet_not_contains_nocase: String
    nounlet_not_ends_with: String
    nounlet_not_ends_with_nocase: String
    nounlet_not_in: [String!]
    nounlet_not_starts_with: String
    nounlet_not_starts_with_nocase: String
    nounlet_starts_with: String
    nounlet_starts_with_nocase: String
    reason: String
    reason_contains: String
    reason_contains_nocase: String
    reason_ends_with: String
    reason_ends_with_nocase: String
    reason_gt: String
    reason_gte: String
    reason_in: [String!]
    reason_lt: String
    reason_lte: String
    reason_not: String
    reason_not_contains: String
    reason_not_contains_nocase: String
    reason_not_ends_with: String
    reason_not_ends_with_nocase: String
    reason_not_in: [String!]
    reason_not_starts_with: String
    reason_not_starts_with_nocase: String
    reason_starts_with: String
    reason_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    voteAmount: BigInt
    voteAmount_gt: BigInt
    voteAmount_gte: BigInt
    voteAmount_in: [BigInt!]
    voteAmount_lt: BigInt
    voteAmount_lte: BigInt
    voteAmount_not: BigInt
    voteAmount_not_in: [BigInt!]
}

input Delegate_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nounletsRepresentedIDs: [String!]
    nounletsRepresentedIDs_contains: [String!]
    nounletsRepresentedIDs_contains_nocase: [String!]
    nounletsRepresentedIDs_not: [String!]
    nounletsRepresentedIDs_not_contains: [String!]
    nounletsRepresentedIDs_not_contains_nocase: [String!]
    nounletsRepresented_: Nounlet_filter
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    votes_: DelegateVote_filter
}

input Noun_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    currentDelegate: String
    currentDelegate_contains: String
    currentDelegate_contains_nocase: String
    currentDelegate_ends_with: String
    currentDelegate_ends_with_nocase: String
    currentDelegate_gt: String
    currentDelegate_gte: String
    currentDelegate_in: [String!]
    currentDelegate_lt: String
    currentDelegate_lte: String
    currentDelegate_not: String
    currentDelegate_not_contains: String
    currentDelegate_not_contains_nocase: String
    currentDelegate_not_ends_with: String
    currentDelegate_not_ends_with_nocase: String
    currentDelegate_not_in: [String!]
    currentDelegate_not_starts_with: String
    currentDelegate_not_starts_with_nocase: String
    currentDelegate_starts_with: String
    currentDelegate_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nounlets_: Nounlet_filter
}

input Nounlet_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    auction_: Auction_filter
    delegate: String
    delegateVotes_: DelegateVote_filter
    delegate_: Delegate_filter
    delegate_contains: String
    delegate_contains_nocase: String
    delegate_ends_with: String
    delegate_ends_with_nocase: String
    delegate_gt: String
    delegate_gte: String
    delegate_in: [String!]
    delegate_lt: String
    delegate_lte: String
    delegate_not: String
    delegate_not_contains: String
    delegate_not_contains_nocase: String
    delegate_not_ends_with: String
    delegate_not_ends_with_nocase: String
    delegate_not_in: [String!]
    delegate_not_starts_with: String
    delegate_not_starts_with_nocase: String
    delegate_starts_with: String
    delegate_starts_with_nocase: String
    holder: String
    holder_: Account_filter
    holder_contains: String
    holder_contains_nocase: String
    holder_ends_with: String
    holder_ends_with_nocase: String
    holder_gt: String
    holder_gte: String
    holder_in: [String!]
    holder_lt: String
    holder_lte: String
    holder_not: String
    holder_not_contains: String
    holder_not_contains_nocase: String
    holder_not_ends_with: String
    holder_not_ends_with_nocase: String
    holder_not_in: [String!]
    holder_not_starts_with: String
    holder_not_starts_with_nocase: String
    holder_starts_with: String
    holder_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    noun: String
    noun_: Noun_filter
    noun_contains: String
    noun_contains_nocase: String
    noun_ends_with: String
    noun_ends_with_nocase: String
    noun_gt: String
    noun_gte: String
    noun_in: [String!]
    noun_lt: String
    noun_lte: String
    noun_not: String
    noun_not_contains: String
    noun_not_contains_nocase: String
    noun_not_ends_with: String
    noun_not_ends_with_nocase: String
    noun_not_in: [String!]
    noun_not_starts_with: String
    noun_not_starts_with_nocase: String
    noun_starts_with: String
    noun_starts_with_nocase: String
}

input Token_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    accounts_: Account_filter
    delegates_: Delegate_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

input Vault_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    noun: String
    nounInVault: Boolean
    nounInVault_in: [Boolean!]
    nounInVault_not: Boolean
    nounInVault_not_in: [Boolean!]
    noun_: Noun_filter
    noun_contains: String
    noun_contains_nocase: String
    noun_ends_with: String
    noun_ends_with_nocase: String
    noun_gt: String
    noun_gte: String
    noun_in: [String!]
    noun_lt: String
    noun_lte: String
    noun_not: String
    noun_not_contains: String
    noun_not_contains_nocase: String
    noun_not_ends_with: String
    noun_not_ends_with_nocase: String
    noun_not_in: [String!]
    noun_not_starts_with: String
    noun_not_starts_with_nocase: String
    noun_starts_with: String
    noun_starts_with_nocase: String
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}
